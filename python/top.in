#!@PYTHON@

import os as _os
import numpy as _np
from distutils.dir_util import mkpath as _mkpath
import matplotlib.pyplot as _plt

version = '@VERSION@'

class _abs_model:
    def get_field(selft, fname):
        n1, n2 = libtop.modelpy.get_field_size(fname)
        return libtop.modelpy.get_field(fname, n1, n2)

def _error(msg):
    raise Exception(msg)

def get_compiled_files():
    """
    Get the list of compiled equation files (that can be loaded with
    :py:func:`load`)

    :rtype: [str]
    :return: List of compiled equation files
    """
    files = []
    for dirpath, dirnames, filenames in _os.walk('@abs_top_builddir@/src/lib'):
        for filename in filenames:
            if not filename.startswith('lib') and filename.endswith('.so'):
                files.append(filename[0:-3])
    return files

def load(name):
    """
    Load a compiled equation file

    :param str name: Name of the compiled equation file
    """
    import sys
    import importlib

    sys.path.append('@abs_top_builddir@/src/lib/')
    global libtop
    libtop = importlib.import_module(name)

    global leg
    leg = libtop.legpy

def get_lib_version():
    """
    Get loaded library TOP version
    """
    return libtop.toppy.get_version().strip()

def read_dati(datifile):
    """
    Read a 'dati' file and initialize internal variables with values defined in it

    :param str datifile: File to read
    """
    if _os.access(datifile, _os.F_OK):
        libtop.toppy.read_dati(datifile)
        global dati
        dati = libtop.inputs
    else:
        _error('%s: not such file' % dati)

def run_arncheb(shift):
    """
    Run the Arnoldi-Chebyshev method

    :param float shift: Initial shift
    """

    libtop.toppy.init_arncheb()
    libtop.toppy.py_run_arncheb(shift)
    return

def get_nsol():
    """
    Return the number of solutions computed by Arnoldi-Chebyshev method

    :rtype: int
    :return: number of solutions
    """
    return libtop.toppy.get_nsol_out()

def _get_adim():
    return libtop.toppy.get_adim()

def get_valps():
    """
    Retrieve eigenvalues computed by :py:func:`top.run_arncheb`

    :rtype: numpy.ndarray
    :return: An array of eigenvalue
    """
    if libtop == None:
        _error('No library loaded')
        return
    n = get_nsol()
    dtype = get_dtype()
    if dtype == 'real':
        valps = libtop.toppy.get_valps_real(n)
    elif dtype == 'cplx':
        valps = libtop.toppy.get_valps_cplx(n)
    else:
        _error('Unknown type `%s\'' % dtype)
    return  valps

def get_dtype():
    return libtop.toppy.dtype().strip()

def get_vecps():
    """
    Return the eigenvectors computed by :py:func:`top.run_arncheb`

    :rtype: numpy.ndarray
    :return: An array of eigenvector
    """

    n = get_nsol()
    adim = _get_adim()

    dtype = get_dtype()
    if dtype == 'real':
        vecps = libtop.toppy.get_vecps_real(n, adim)
    elif dtype == 'cplx':
        vecps = libtop.toppy.get_vecps_cplx(n, adim)
    else:
        _error('Unknown type `%s\'' % dtype)
    return vecps

def init_model(filename):
    """
    Initialize the model by calling the Fortran routine init_model of the model
    compiled with the equation file currently loaded.

    :param str filename: Filename or directory to read in order to initialize the model
    """

    libtop.toppy.py_init_model(filename)
    global model
    model = _abs_model()

def get_grid():
    """
    Return the grid

    :rtype: numpy.ndarray
    :return: The grid of the model
    """

    nr = libtop.toppy.get_nr()
    return libtop.toppy.get_grid(nr)

def get_model_field(fname):
    n1, n2 = libtop.toppy.model_get_field_size(fname)
    return libtop.toppy.model_get_field(fname, n1, n2)

def write_output(directory):
    """
    Writes TOP's output to directory

    :param str directory: directory where to save Arnoldi-Chebyshev method's output
    """
    if directory[-1] != '/':
        directory = '%s/' % directory
    if not _os.access(directory, _os.F_OK):
        d = _mkpath(directory)
    libtop.toppy.pywrite_output(directory)

def get_sol(idom, isol, var):
    """
    Get a solution

    :param int idom: domain of the solution
    :param int isol: solution number
    :param str var: name of the variable
    :rtype: tuple
    :return: eigenvalue and eigenvector of the isol'th solution in the idom'th domain of variable var
    """
    nr, nt = libtop.toppy.get_solsize(idom+1)
    valp, vecp = libtop.toppy.get_sol_real(idom+1, isol+1, var, nr, nt)
    l = libtop.toppy.pyget_lvar(idom+1, var, nt)
    return valp, vecp, l

def get_ndom():
    """
    Returns the number of domains of the problem

    :rtype: int
    :return: number of domains
    """
    return libtop.toppy.get_ndom()

def get_vars(idom):
    """
    Returns the list of variables defined in a domain

    :param int idom: domain
    :rtype: [str]
    :return: list of variables in the idom'th domain
    """
    nvars = libtop.toppy.get_nvars(idom+1)
    ret = []
    for i in range(0, nvars):
        v = libtop.toppy.get_var_name(idom+1, i+1)
        ret.append(v.strip())
    return ret

def plot(idom, isol, var, m=0, nth=180):
    """
    Plots isol'th solution of variable var in domain number idom

    :param int idom: domain
    :param int isol: solution to plot
    :param str var: variable to plot
    :param int nth: number of theta point for the projection to real space
    """
    theta = _np.linspace(_np.pi, 0, nth)
    r = get_grid()
    cost = _np.cos(theta)
    sint = _np.sin(theta)

    rs = 0
    for ir in range(0, idom):
        _, vec, _ = get_sol(idom, isol, var)
        rs = rs + vec.shape[0]

    val, vec, l = get_sol(idom, isol, var)
    fg = leg.eval2d(vec, cost, l[0], 2, m)
    r = r[rs:rs+vec.shape[0]]
    x = _np.outer(r, sint)
    y = _np.outer(r, cost)

    _plt.pcolormesh(x, y, fg)
    _plt.title(var)
    _plt.colorbar()
    _plt.show()
