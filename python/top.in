#!@PYTHON@

import os as _os
import sys as _sys
import numpy as _np
import h5py as _h5py
import importlib as _importlib
import matplotlib.pyplot as _plt
from distutils.dir_util import mkpath as _mkpath

version = '@VERSION@'

_sys.path.append('@abs_top_builddir@/src/')
import legpy as _legpy
leg = _legpy.legpy

def _error(msg):
    raise Exception(msg)

class _abs_model:
    def get_field(self, fname):
        n1, n2 = libtop.modelpy.get_field_size(fname)
        return libtop.modelpy.get_field(fname, n1, n2)

class results:
    def __init__(self, result_file = ''):
        if result_file == '':
            self.from_top()
        else:
            self.from_file(result_file)

    def from_file(self, h5result):

        self.valps = []
        self.vecps = []
        self.l = []

        f = _h5py.File(h5result, 'r')
        self.nsol = len(f['/']) - 2 # minus r and theta fields
        self.model = f.attrs['model']
        self.shift = f.attrs['shift']
        self.lres = f.attrs['lres']
        self.ndom = len(f['sol0'].keys())
        self.vars = []
        self.nr = []

        zeta = []
        for isol in range(0, self.nsol):
            self.vecps.append([])
            self.l.append([])
            sgrp = f['/sol%d' % (isol)]
            self.valps.append(sgrp.attrs['valp'])
            for idom in range(0, self.ndom):
                valp = {}
                vecps = {}
                ls = {}
                vars = []
                grp = f['/sol%d/dom%d' % (isol, idom)]
                if isol == 0:
                    dom_grid = grp.attrs['zeta']
                    self.nr.append(len(dom_grid))
                    zeta.append(dom_grid)
                for var in grp.keys():
                    vars.append(var)
                    vdset = f['/sol%d/dom%d/%s' % (isol, idom, var)]
                    vecps[var] = vdset[:, :]
                    ls[var] = vdset.attrs['l']

                self.vecps[-1].append(vecps)
                self.l[-1].append(ls)
                if isol == 0:
                    self.vars.append([])
                    self.vars[-1] = vars

        self.zeta = _np.zeros(shape = sum(self.nr))
        for idom in range(0, self.ndom):
            skip = sum(self.nr[0:idom])
            self.zeta[skip:skip+self.nr[idom]] = _np.array(zeta[idom])
        self.r = f['/r'][:, :]
        self.theta = f['/theta'][:]
        f.close()

    def from_top(self):
        self.nsol = get_nsol()
        self.ndom = get_ndom()
        self.valps = []
        self.vecps = []
        self.l = []
        self.vars = []
        self.shift = _actual_shift
        self.model = _actual_model
        self.nr = []
        self.r, self.theta = _get_grid()
        self.zeta = _get_zeta()
        self.lres = dati.lres

        for idom in range(0, self.ndom):
            self.vars.append(_get_vars(idom))
            self.nr.append(libtop.toppy.get_dom_nr(idom+1))

        for isol in range(0, self.nsol):
            self.valps.append(0.0)
            self.vecps.append([])
            self.l.append([])
            for idom in range(0, self.ndom):
                vecps = {}
                ls = {}
                for var in self.vars[idom]:
                    valp, vecp, l = _get_sol(idom, isol, var)
                    vecps[var] = vecp
                    ls[var] = l
                self.vecps[-1].append(vecps)
                self.l[-1].append(ls)
            self.valps[isol] = valp

    def get_sol(self, idom, isol, var):
        valp = self.valps[isol]
        vecp = self.vecps[isol][idom][var]
        l = self.l[isol][idom][var]
        return valp, vecp, l

    def get_grid(self, idom = -1):
        if idom >= 0:
            skip = 0
            for i in range(0, idom):
                nr = self.nr[i]
                skip = skip + nr
            nr = self.nr[idom]
            return self.r[skip:skip+nr], self.theta
        else:
            return self.r, self.theta

    def save(self, h5file):
        f = _h5py.File(h5file, 'w')
        f.attrs['model'] = self.model
        f.attrs['shift'] = self.shift
        f.attrs['lres'] = self.lres
        valp = 0.0
        f.create_dataset('r', data = self.r)
        f.create_dataset('theta', data = self.theta)
        for isol in range(0, self.nsol):
            sgrp = f.create_group('sol%d' % isol)
            skip = 0
            for idom in range(0, self.ndom):
                nr = self.nr[idom]
                dgrp = sgrp.create_group('dom%d' % idom)
                dgrp.attrs['zeta'] = self.zeta[skip:skip+nr]
                skip = skip + nr
                for var in self.vars[idom]:
                    valp, vecp, l = self.get_sol(idom, isol, var)
                    dset = dgrp.create_dataset(var, data = vecp)
                    dset.attrs['l'] = l
            sgrp.attrs['valp'] = valp
        f.close()

    def plot(self, idom, isol, var, m=0, nth=180):
        """
        Plots isol'th solution of variable var in domain number idom

        :param int idom: domain
        :param int isol: solution to plot
        :param str var: variable to plot
        :param int nth: number of theta point for the projection to real space
        """

        val, vec, l = self.get_sol(idom, isol, var)

        r, theta = self.get_grid(idom)
        cost = _np.cos(theta)
        sint = _np.sin(theta)

        # fg = vec
        fg = leg.eval2d(vec, cost, l[0], 2, m)

        x = r * sint
        y = r * cost

        _plt.pcolormesh(x, y, fg)
        _plt.title(var)
        # _plt.colorbar()
        _plt.show()

def get_compiled_files():
    """
    Get the list of compiled equation files (that can be loaded with
    :py:func:`load`)

    :rtype: [str]
    :return: List of compiled equation files
    """
    files = []
    for dirpath, dirnames, filenames in _os.walk('@abs_top_builddir@/src/lib'):
        for filename in filenames:
            if not filename.startswith('lib') and filename.endswith('.so'):
                files.append(filename[0:-3])
    return files

def load(name):
    """
    Load a compiled equation file

    :param str name: Name of the compiled equation file
    """

    _sys.path.append('@abs_top_builddir@/src/lib/')
    global libtop
    libtop = _importlib.import_module(name)

def get_lib_version():
    """
    Get loaded library TOP version
    """
    return libtop.toppy.get_version().strip()

def read_dati(datifile):
    """
    Read a 'dati' file and initialize internal variables with values defined in it

    :param str datifile: File to read
    """
    if _os.access(datifile, _os.F_OK):
        libtop.toppy.read_dati(datifile)
        global dati
        dati = libtop.inputs
    else:
        _error('%s: not such file' % datifile)

def run_arncheb(shift):
    """
    Run the Arnoldi-Chebyshev method

    :param float shift: Initial shift
    """

    try:
        global _actual_shift
        _actual_shift = shift
        libtop.toppy.init_arncheb()
        libtop.toppy.py_run_arncheb(shift)
    except NameError:
        _error("No library loaded")

def get_nsol():
    """
    Return the number of solutions computed by Arnoldi-Chebyshev method

    :rtype: int
    :return: number of solutions
    """
    try:
        return libtop.toppy.get_nsol_out()
    except NameError:
        _error("You did not run `run_arncheb\' yet")

def _get_adim():
    return libtop.toppy.get_adim()

def get_valps():
    """
    Retrieve eigenvalues computed by :py:func:`top.run_arncheb`

    :rtype: numpy.ndarray
    :return: An array of eigenvalue
    """
    try:
        n = get_nsol()
        dtype = get_dtype()
        if dtype == 'real':
            valps = libtop.toppy.get_valps_real(n)
        elif dtype == 'cplx':
            valps = libtop.toppy.get_valps_cplx(n)
        else:
            _error('Unknown type `%s\'' % dtype)
        return  valps
    except NameError:
        _error("You did not run `run_arncheb\' yet")

def get_dtype():
    return libtop.toppy.dtype().strip()

def get_vecps():
    """
    Return the eigenvectors computed by :py:func:`top.run_arncheb`

    :rtype: numpy.ndarray
    :return: An array of eigenvector
    """
    try:
        n = get_nsol()
        adim = _get_adim()

        dtype = get_dtype()
        if dtype == 'real':
            vecps = libtop.toppy.get_vecps_real(n, adim)
        elif dtype == 'cplx':
            vecps = libtop.toppy.get_vecps_cplx(n, adim)
        else:
            _error('Unknown type `%s\'' % dtype)
        return vecps
    except NameError:
        _error("You did not run `run_arncheb\' yet")

def init_model(filename):
    """
    Initialize the model by calling the Fortran routine init_model of the model
    compiled with the equation file currently loaded.

    :param str filename: Filename or directory to read in order to initialize the model
    """
    try:
        global _actual_model
        if type(filename) == str:
            _actual_model = filename
        else:
            _actual_model = filename.tostring().strip()
        libtop.toppy.py_init_model(filename)
        global model
        model = _abs_model()
    except NameError:
        _error("No library loaded")

def _get_grid():
    """
    Return the grid

    :rtype: numpy.ndarray
    :return: The grid of the model
    """

    nr, nt = libtop.toppy.get_grid_size()
    return libtop.toppy.get_grid(nr, nt)

def _get_zeta():
    """
    Return the radial grid in zeta coordinate

    :rtype: numpy.ndarray
    :return: The grid of the model
    """

    nr, _ = libtop.toppy.get_grid_size()
    return libtop.toppy.get_zeta(nr)

def get_model_field(fname):
    n1, n2 = libtop.toppy.model_get_field_size(fname)
    return libtop.toppy.model_get_field(fname, n1, n2)

def write_output(directory):
    """
    Writes TOP's output to directory

    :param str directory: directory where to save Arnoldi-Chebyshev method's output
    """
    if directory[-1] != '/':
        directory = '%s/' % directory
    if not _os.access(directory, _os.F_OK):
        d = _mkpath(directory)
    libtop.toppy.pywrite_output(directory)

def _get_sol(idom, isol, var):
    """
    Get a solution

    :param int idom: domain of the solution
    :param int isol: solution number
    :param str var: name of the variable
    :rtype: tuple
    :return: eigenvalue and eigenvector of the isol'th solution in the idom'th domain of variable var
    """
    nr, nt = libtop.toppy.get_solsize(idom+1)
    valp, vecp = libtop.toppy.get_sol_real(idom+1, isol+1, var, nr, nt)
    l = libtop.toppy.pyget_lvar(idom+1, var, nt)
    return valp, vecp, l

def get_ndom():
    """
    Returns the number of domains of the problem

    :rtype: int
    :return: number of domains
    """
    return libtop.toppy.get_ndom()

def _get_vars(idom):
    """
    Returns the list of variables defined in a domain

    :param int idom: domain
    :rtype: [str]
    :return: list of variables in the idom'th domain
    """
    nvars = libtop.toppy.get_nvars(idom+1)
    ret = []
    for i in range(0, nvars):
        v = libtop.toppy.get_var_name(idom+1, i+1)
        ret.append(v.strip())
    return ret
