#!/usr/bin/perl

if (scalar @ARGV < 1) {die "Usage: readeq eq_file\n";}

$input  = $ARGV[0];
$output = "matrices.inc";

$ncols=80;
$lincr=2;

@src = ();
@src_nline = ();
$nline=0;
open(SOURCE, "< $input") or die "File $input not found.\n";
foreach $chaine(<SOURCE>) {
  $nline++;
  push @src, $chaine;
  push @src_nline, $nline;
}
close SOURCE;
&expand;
#&printsource;  # uncomment if you want to see expanded source

&cleardefs;
&setdefault;
foreach $chaine(@src) {
  $chaine =~ s/\#.*//; # this removes comments

  @list = split (" ",$chaine);
     if ($list[0] eq "domains")  {&readdomains;&initcounters;}
  elsif ($list[0] eq "varlist")  {&readvarlist;}
  elsif ($list[0] eq "eqlist")   {&readeqlist;}
  elsif ($list[0] eq "equation") {&seteq;}
  elsif(($list[0] eq "term") or ($list[0] eq "termbc") or
        ($list[0] eq "sub") or ($list[0] eq "subbc") or
        ($list[0] eq "termi") or ($list[0] eq "termbci") or
        ($list[0] eq "subi") or ($list[0] eq "subbci")) {&countterm;}
  elsif ($list[0] eq "definition") {&add_definition;}
  $nline++;
}
&sanity_check;

open(PUITS, "> $output") or die "Cannot write to $output.\n";
&writehead;
&setdefault;
&initcounters;
foreach $chaine(@src) {
  $chaine =~ s/\#.*//; # this removes comments

  @list = split (" ",$chaine);
     if ($list[0] eq "equation") {&seteq;}
  elsif ($list[0] eq "term")     {&addterm;}
  elsif ($list[0] eq "termi")    {&addterm;}
  elsif ($list[0] eq "termbc")   {&addtermbc;}
  elsif ($list[0] eq "termbci")  {&addtermbc;}
  elsif ($list[0] eq "sub")      {&callsub;}
  elsif ($list[0] eq "subi")     {&callsub;}
  elsif ($list[0] eq "subbc")    {&callsubbc;}
  elsif ($list[0] eq "subbci")   {&callsubbc;}
  elsif ($list[0] eq "input")    {&addinput;}
  elsif ($list[0] eq "stamp")    {$stamp = join(" ",@list[1..(scalar @list - 1)]);}
  elsif ($list[0] eq "instruction") {&writeinstruction;}
  elsif ($list[0] eq "leq")      {&setleq;}
  elsif ($list[0] eq "lvar")     {&setlvar;}
  elsif ($list[0] eq "suppress") {&suppressvar;}
  elsif ($list[0] eq "domains")    {}
  elsif ($list[0] eq "varlist")    {}
  elsif ($list[0] eq "eqlist")     {}
  elsif ($list[0] eq "definition") {}
  elsif ($list[0] eq "macro")      {}
  elsif (scalar @list >= 1)
    {die "Error on line $src_nline[$nline]: \"$list[0]\" unknown command.\n";}
  $nline++;
}
&writetail;
# &writegrid;
&writeinputs;
close PUITS;

########################################################################
# This expands do loops:
########################################################################
sub expand{
  $nline = 0;
  $end = scalar @src;
  while ($nline < $end) {
    $chaine = $src[$nline];
    $chaine =~ s/\#.*//; # this removes comments
    @list = split (" ",$chaine);
    if ($list[0] eq "macro") {
      if (scalar @list < 3) {die "Error on line $src_nline[$nline]: missing terms.\n";}
      $macro = $list[1];
      $macro_sub = join(" ",@list[2..(scalar @list - 1)]);
      for($i=$nline+1;$i<$end;$i++) {$src[$i] =~ s/$macro/$macro_sub/g;}
    }
    if ($list[0] eq "enddo") {die "Error on line $src_nline[$nline]: stray enddo.\n";}
    if ($list[0] eq "do") {

      # check number of terms and set up arguments:
      if (scalar @list < 4) {die "Error on line $src_nline[$nline]: missing terms.\n";}
      $dummy = $list[1];
      $start = $list[2];
      $stop  = $list[3];
      if (scalar @list > 4) {
        $incr = $list[4];
      } else {
        $incr = 1;
      }

      # Sanity check: make sure $start, $stop, and $incr are integers,
      # and that the loop will stop.
      if (($start !~ /^\-?\d+$/)||($stop !~ /^\-?\d+$/)||($incr !~ /^\-?\d+$/)) {
        die "Error on line $src_nline[$nline]: non-integer loop arguments.\n";
      }
      if ($incr == 0) { die "Error on line $src_nline[$nline]: infinite loop.\n"; }
      if ($incr*($stop-$start) < 0) {
        print "Warning on line $src_nline[$nline]: empty loop.\n";
      }

      # find closing "enddo" (the depth has to match):
      $depth = 1;
      $endline = $nline+1;
      while ($endline < $end) {
        $chaine = $src[$endline];
        $chaine =~ s/\#.*//; # this removes comments
        @list = split(" ",$chaine);
        if ($list[0] eq "do") {$depth++;}
        if ($list[0] eq "enddo") {$depth--;}
        if ($depth == 0) {last;}
        $endline++;
      }
      if ($endline >= $end) {die "Error on line $src_nline[$nline]: unfinished loop\n";}

      # remove lines which need to be duplicated
      # NOTE: mastercopy contains the opening and closing "do" and "enddo"
      #       hence the $lngth+2 argument in the splice command.
      $lngth = $endline-$nline-1;
      @mastercopy = splice(@src,$nline,$lngth+2);
      @copy_nline = splice(@src_nline,$nline,$lngth+2);
      @copy_nline = splice(@copy_nline,1,$lngth); # remove first and

      # make copies and reinsert them
      # allow very basic arithmetic operations
      $counter = 0;
      if ($incr > 0) {$sign = 1;} else {$sign = -1;} 
      for($dummy_value=$start;$dummy_value*$sign<=$stop*$sign;$dummy_value+=$incr) {
        @copy = ();
        for($i=1;$i<=$lngth;$i++) {
          $chaine = $mastercopy[$i];
          while ($chaine =~ m/${dummy}\+\+/) {
            $aux_value = $dummy_value + 1;
            $chaine =~ s/${dummy}\+\+/$aux_value/;
          }
          while ($chaine =~ m/${dummy}--/) {
            $aux_value = $dummy_value - 1;
            $chaine =~ s/${dummy}--/$aux_value/;
          }
          while ($chaine =~ m/${dummy}\+\d+/) {
            $aux_value = $chaine;
            $aux_value =~ s/.*${dummy}\+(\d+)\D.*/$1/;
            $aux_value = $dummy_value + $aux_value;
            $chaine =~ s/${dummy}\+\d+/$aux_value/;
          }
          while ($chaine =~ m/${dummy}-\d+/) {
            $aux_value = $chaine;
            $aux_value =~ s/.*${dummy}-(\d+)\D.*/$1/;
            $aux_value = $dummy_value - $aux_value;
            $chaine =~ s/${dummy}-\d+/$aux_value/;
          }
          while ($chaine =~ m/\d+\+${dummy}/) {
            $aux_value = $chaine;
            $aux_value =~ s/.*\D(\d+)\+${dummy}.*/$1/;
            $aux_value = $dummy_value + $aux_value;
            $chaine =~ s/\d+\+${dummy}/$aux_value/;
          }
          while ($chaine =~ m/\d+-${dummy}/) {
            $aux_value = $chaine;
            $aux_value =~ s/.*\D(\d+)-${dummy}.*/$1/;
            $aux_value = $aux_value - $dummy_value;
            $chaine =~ s/\d+-${dummy}/$aux_value/;
          }
          $chaine =~ s/$dummy/$dummy_value/g;
          push @copy,$chaine;
        }
        splice(@src,$nline+$lngth*$counter,0,@copy);
        splice(@src_nline,$nline+$lngth*$counter,0,@copy_nline);
        $counter++;
      }
    }
    $nline++;
    $end = scalar @src; # VERY important
  } 
}
########################################################################
# This outputs the expanded source (for debugging purposes only)
########################################################################
sub printsource{
  open(PUITS, "> ${input}_expanded") or die "Cannot write to $output.\n";
  foreach $chaine(@src) {print PUITS "$chaine";}
  close(PUITS);
  die "Expanded eq file in ${input}_expanded\n";
}
########################################################################
sub cleardefs{
  @defs_type  = ();
  @defs       = ();
  @defs_value = ();
}
########################################################################
sub setdefault{
  $nline      = 0;
  $power_max  = 0;
  @inputs          = ('shift_real','shift_imag','rootdir','nsol');
  @inputs_format   = ('f7.4','f7.4','A','I2');
  @inputs_datatype = ('double precision','double precision','character*(512)','integer');
  @inputs_value    = ('0d0','0d0',"'no_dir'",'4');
  $current_equation = "no_eq";
  $prev = "empty";
  @amat = (); # this contains the instructions for the coupling coefficients
  @imat = (); # this contains the instructions which specify the indices in
              # the asi, arti, artti, atbci and attbci matrices
  @asub = (); # this contains the calls to the subroutines which calculate the
              # coupling coefficients
  @isub = (); # this contains the calls to the subroutine which specify the
              # indicies in the asi, arti, artti, atbci and attbci matrices
  push @asub, "      call eq_$current_equation()\n";
  push @amat, "!".("-"x60)."\n";
  push @amat, "! Preliminary instructions\n";
  push @amat, "!".("-"x60)."\n";
  push @amat, "      subroutine eq_$current_equation()\n";
  push @amat, "      use model\n";
  push @amat, "      use inputs\n";
  push @amat, "      use integrales\n";
  push @amat, "      implicit none\n";
  push @amat, "      integer i, j, jj\n";
}
########################################################################
sub readdomains{
  if (scalar @list < 2) {die "Error on line $src_nline[$nline]: empty domain list!\n";}

  # Create a list of domains and count their number:
  %domainlist = ();
  for ($i=1; $i < scalar @list; $i++) {
    if (exists $domainlist{$list[$i]}) {
      die "Error on line $src_nline[$nline]: repeated domain name.\n";
    } else {
      $domainlist{$list[$i]} = $i;
    }
  }
  $ndomains = scalar keys(%domainlist);
  print "Number of domains: $ndomains\n";

  # initialise different arrays to do with equations and variables:
  %vardomain = ();
  %varindex = ();
  %eqdomain = ();
  %eqindex = ();
}
########################################################################
sub initcounters{
  # Initialise some variables based on the number of domains:
  @nvar = ();
  @nas = ();
  @nart = ();
  @nartt = ();
  @natbc = ();
  @nattbc = ();
  @nvardomain = ();
  @neqdomain = ();
  for($i=1;$i<=$ndomains;$i++) {
    $nvar[$i] = 0;
    $nas[$i] = 0;
    $nart[$i] = 0;
    $nartt[$i] = 0;
    $nvardomain[$i] = 0;
    $neqdomain[$i] = 0;
    for($j=1;$j<=$ndomains;$j++) {
      $natbc[$i][$j] = 0;
      $nattbc[$i][$j] = 0;
    }
  }
}
########################################################################
sub readvarlist{
  if (scalar @list < 3) {die "Error on line $src_nline[$nline]: empty variable list!\n";}

  if (exists $domainlist{$list[1]}) {
    $domainNumber = $domainlist{$list[1]};
  } else {
    die "Error on line $src_nline[$nline]: \"$list[1]\" unknown domain\n";
  }

  for($i=2; $i < scalar @list; $i++) {
    if (exists $vardomain{$list[$i]}) {
      die "Error on line $src_nline[$nline]: variable \"$list[$i]\" already exists\n";
    } else {
      $vardomain{$list[$i]} = $domainNumber;
      $varindex{$list[$i]} = $i-1;
      $nvardomain[$domainNumber]++;
    }
  }
}
########################################################################
sub readeqlist{
  if (scalar @list < 3) {die "Error on line $src_nline[$nline]: empty equation list!\n";}

  if (exists $domainlist{$list[1]}) {
    $domainNumber = $domainlist{$list[1]};
  } else {
    die "Error on line $src_nline[$nline]: \"$list[1]\" unknown domain\n";
  }

  for($i=2; $i < scalar @list; $i++) {
    if (exists $eqdomain{$list[$i]}) {
      die "Error on line $src_nline[$nline]: equation \"$list[$i]\" already exists\n";
    } else {
      $eqdomain{$list[$i]} = $domainNumber;
      $eqindex{$list[$i]} = $i-1;
      $neqdomain[$domainNumber]++;
    }
  }
}
########################################################################
sub seteq{
  if (scalar @list < 2) {die "Error on line $src_nline[$nline]: missing terms.\n";}
  if (scalar @list > 2) {die "Error on line $src_nline[$nline]: too many terms.\n";}

  if ($current_equation ne "no_eq") {
    push @imat, "      end subroutine eqi_$current_equation\n";
  }
  push @amat, "      end subroutine eq_$current_equation\n";
  if (exists $eqdomain{$list[1]}) {
    $domainNumber = $eqdomain{$list[1]};
    $equation = $eqindex{$list[1]};
    $current_equation = $list[1];
    push @asub, "      call eq_$current_equation()\n";
    push @isub, "      call eqi_$current_equation()\n";
    push @amat, "!".("-"x60)."\n";
    push @amat, "! Coupling coefficients for equation $list[1]\n";
    push @amat, "!".("-"x60)."\n";
    push @amat, "      subroutine eq_$current_equation()\n\n";
    push @amat, "      use model\n";
    push @amat, "      use inputs\n";
    push @amat, "      use integrales\n";
    push @amat, "      implicit none\n";
    push @amat, "      integer i,j,jj\n";
    push @imat, "!".("-"x60)."\n";
    push @imat, "! Indices for equation $list[1]\n";
    push @imat, "!".("-"x60)."\n";
    push @imat, "      subroutine eqi_$current_equation()\n\n";
    push @imat, "      use model\n";
    push @imat, "      use inputs\n";
    push @imat, "      implicit none\n";
  } else {
    die "Error on line $src_nline[$nline]: \"$list[1]\" unknown equation\n";
  }
}
########################################################################
sub countterm{
  if (($list[0] eq "term") or ($list[0] eq "sub") or
      ($list[0] eq "termi") or ($list[0] eq "subi"))
  {
    if (scalar @list < 2) {die "Error on line $src_nline[$nline]: many terms missing.\n";}
       if ($list[1] eq "s")   {$nas[$domainNumber]++;}
    elsif ($list[1] eq "rt")  {$nart[$domainNumber]++;}
    elsif ($list[1] eq "rtt") {$nartt[$domainNumber]++;}
    else {die "Error on line $src_nline[$nline]: unrecognised term type.\n";}
  }
  elsif (($list[0] eq "termbc") or ($list[0] eq "subbc") or
         ($list[0] eq "termbci") or ($list[0] eq "subbci"))
  {
    if (scalar @list < 2) {die "Error on line $src_nline[$nline]: many terms missing.\n";}
    $varname = $list[-1];   # select last element;
    $varname =~ s/\(.*\)//; # remove parenthesis and its content
    $varname =~ s/'//g;     # remove apostrophes
    $varname =~ s/\^.*//;   # remove "^anything"
    if (exists $vardomain{$varname}) {
      $varDomainNumber = $vardomain{$varname};
    } else {
      die "Error on line $src_nline[$nline]: \"$varname\" unknown variable\n";
    }
       if ($list[1] eq "t")  {$natbc[$domainNumber][$varDomainNumber]++;}
    elsif ($list[1] eq "tt") {$nattbc[$domainNumber][$varDomainNumber]++;}
    else {die "Error on line $src_nline[$nline]: unrecognised term type.\n";}
  }
  else {die "Error on line $src_nline[$nline]: Programming error in readeq.\n";}
}
########################################################################
# this checks to see if the number of equations
# matches the number of variables in each domain
sub sanity_check{
  for($i=1; $i<=$ndomains; $i++) {
    if ($neqdomain[$i] != $nvardomain[$i]) {
      die "Error: domain(s) with inconsistent number of equations and variables\n";
    }
  }
}
########################################################################
sub writehead{
  print PUITS "      subroutine init_a() bind(c)\n\n";
  print PUITS "      use model\n";
  print PUITS "      use inputs\n";
  print PUITS "      use integrales\n\n";
  print PUITS "      implicit none\n";
  print PUITS "      integer i,j,jj,id,der_min,der_max\n";

  for($i=0; $i < scalar @defs; $i++) {
    print PUITS mywrap("      $defs[$i] = $defs_value[$i]",$ncols);
  }
  print PUITS "\n";

  print PUITS "      if (.not.first_run) call clear_all()\n";
  print PUITS "      allocate(dm(ndomains),idm(ndomains,ndomains))\n\n";

  for($i=1;$i<=$ndomains;$i++) {
    print PUITS "      dm($i)\%nvar=$nvardomain[$i]\n";
    print PUITS "      dm($i)\%nas=$nas[$i]\n";
    print PUITS "      dm($i)\%nart=$nart[$i]\n";
    print PUITS "      dm($i)\%nartt=$nartt[$i]\n";
  }

  for($i=1;$i<=$ndomains;$i++) {
    for($j=1;$j<=$ndomains;$j++) {
      print PUITS "      idm($i,$j)\%natbc=$natbc[$i][$j]\n";
      print PUITS "      idm($i,$j)\%nattbc=$nattbc[$i][$j]\n";
    }
  }

  print PUITS "      call allocate_all()\n\n";

  print PUITS "      ! variable names:\n";
  while (($varname,$domainNumber) = each(%vardomain)) {
    print PUITS "      dm($domainNumber)\%var_name".
          "($varindex{$varname}) = \"$varname\"\n";
  }
  print PUITS "\n";

  print PUITS "      ! equation names:\n";
  while (($eqname,$domainNumber) = each(%eqdomain)) {
    print PUITS "      dm($domainNumber)\%eq_name".
          "($eqindex{$eqname}) = \"$eqname\"\n";
  }
  print PUITS "\n";

  print PUITS "      ! initialise var_keep arrays:\n";
  for($i=1;$i<=$ndomains;$i++) {
    print PUITS "      dm($i)\%var_keep=.true.\n";
  }
  print PUITS "\n";

}
########################################################################
sub writetail{
  if ($current_equation ne "no_eq") {
    push @amat, "      end subroutine eq_$current_equation\n";
    push @imat, "      end subroutine eqi_$current_equation\n";
  } else {
    die "You seem to have no equations in $input! Aborting\n";
  }
  for ($i=0; $i < scalar @imat; $i++) {print PUITS "$isub[$i]";}
  print PUITS "      power_max=$power_max\n\n";
  print PUITS "      ! Initialise derivation matrices and dimensions of different\n";
  print PUITS "      ! domains.\n";
  print PUITS "      allocate(dmat(ndomains))\n";
  print PUITS "      a_dim = 0\n";
  print PUITS "      d_dim_max = 0\n";
  print PUITS "      do id=1,ndomains\n";
  print PUITS "        dm(id)%d_dim  = nt*grd(id)%nr*dm(id)%nvar\n";
  print PUITS "        dm(id)%offset = a_dim\n";
  print PUITS "        if (dm(id)%d_dim.gt.d_dim_max) d_dim_max = dm(id)%d_dim\n";
  print PUITS "        a_dim = a_dim + dm(id)%d_dim\n";
  print PUITS "        call find_der_range(der_min,der_max,id)\n";
  print PUITS "        allocate(dm(id)%vect_der(dm(id)%d_dim,der_min:der_max))\n";
  print PUITS "        call init_derive(dmat(id),grd(id)%r,grd(id)%nr,der_max, &\n";
  print PUITS "          der_min,grd(id)%order,grd(id)%dertype)\n";
  print PUITS "      enddo\n";
  print PUITS "      first_run = .false.\n\n";
  print PUITS "      call init_var_list()\n";
  print PUITS "      call find_llmax()\n";
  print PUITS "      print*,'Dimension of problem: ',a_dim\n\n";
  for ($i=0; $i < scalar @imat; $i++) {print PUITS "$asub[$i]";}
  print PUITS "      call integrales_clear()\n";
  print PUITS "      end subroutine init_a\n";
  for ($i=0; $i < scalar @imat; $i++) {print PUITS "$imat[$i]";}
  for ($i=0; $i < scalar @amat; $i++) {print PUITS "$amat[$i]";}
}
########################################################################
sub add_definition{
  $list[3] = join(" ",@list[3..(scalar @list - 1)]);
  if (scalar @list > 4) {splice @list,4;}

  $list[1] =~ s/_/ /g;
  push @defs_type, $list[1];
  push @defs, $list[2];
  push @defs_value, $list[3];
}
########################################################################
sub writeinstruction{
  if (scalar @list < 2) {die "Error on line $src_nline[$nline]: missing arguments\n";}
  $list[1] = join(" ",@list[1..(scalar @list - 1)]);
  if (scalar @list > 2) {splice @list,2;}

  $string = $list[1];
  &treat_string;
  push @amat, mywrap("      $string",$ncols);
  for($i=0;$i<$nloops;$i++) {push @amat, "      enddo\n";}
}
########################################################################
sub suppressvar{
  if (scalar @list < 2) {die "Error on line $src_nline[$nline]: missing arguments\n";}

  for($i=1;$i<scalar @list;$i++) {
    $varname = $list[$i];
    if (exists $vardomain{$varname}) {
      $varDomainNumber = $vardomain{$varname};
      $variable = $varindex{$varname};
    } else {
      die "Error on line $src_nline[$nline]: \"$varname\" unknown variable\n";
    }
    print PUITS "      dm($varDomainNumber)\%var_keep($variable) = .false.\n";
  }
}
########################################################################
sub setleq{
  if (scalar @list < 3) {die "Error on line $src_nline[$nline]: missing arguments\n";}
  if (scalar @list > 3) 
  {
    $list[2] = join(" ",@list[2..(scalar @list - 2)]);
    splice @list,3;
  }

  if (exists $eqdomain{$list[1]}) {
    $domainNumber = $eqdomain{$list[1]};
    $equation = $eqindex{$list[1]};
  } else {
    die "Error on line $src_nline[$nline]: \"$list[1]\" unknown equation\n";
  }

  $dm = "dm($domainNumber)";
  print PUITS "      $dm\%leq(1,$equation) = $list[2]\n";
  print PUITS "      do j=2,nt\n";
  print PUITS "        $dm\%leq(j,$equation) = $lincr + $dm\%leq(j-1,$equation)\n";
  print PUITS "      enddo\n";
}
########################################################################
sub setlvar{
  if (scalar @list < 3) {die "Error on line $src_nline[$nline]: missing arguments\n";}
  if (scalar @list > 3) 
  {
    $list[2] = join(" ",@list[2..(scalar @list - 2)]);
    splice @list,3;
  }

  if (exists $vardomain{$list[1]}) {
    $varDomainNumber = $vardomain{$list[1]};
    $variable = $varindex{$list[1]};
  } else {
    die "Error on line $src_nline[$nline]: \"$list[1]\" unknown variable\n";
  }

  $dm = "dm($varDomainNumber)";
  print PUITS "      $dm\%lvar(1,$variable) = $list[2]\n";
  print PUITS "      do j=2,nt\n";
  print PUITS "        $dm\%lvar(j,$variable) = $lincr + $dm\%lvar(j-1,$variable)\n";
  print PUITS "      enddo\n";
}

########################################################################
sub addterm{
  if (scalar @list < 5) {die "Error on line $src_nline[$nline]: missing terms\n";}
  if (scalar @list > 5) 
  {
    $list[3] = join(" ",@list[3..(scalar @list - 2)]);
    splice @list,4,-1;
  }

  $power = $list[2];
  $power =~ s/w(\d*)/$1/;
  if ($power eq "") {$power = 1;}
  if ($power > $power_max) {$power_max = $power;}

  $der = $list[4];
  if ($der =~ /\^/) {
    $der =~ s/.*\^(.*)/$1/;
  }
  else {
    $der =~ s/[^']//g;
    $der = length($der);
  }

  $varname = $list[4];
  $varname =~ s/'//g;
  $varname =~ s/\^.*//;
  if (not exists $vardomain{$varname}) {
    die "Error on line $src_nline[$nline]: \"$varname\" unknown variable\n";
  }

  $variable = $varindex{$varname};
  $varDomainNumber = $vardomain{$varname};

  if ($varDomainNumber != $domainNumber) {
    die "Error on line $src_nline[$nline]: illegal domain coupling\n";
  }

  $string = $list[3];
  &treat_string;

  if ($list[0] eq 'termi') {
    $iscomplex = 1;
  } else {
    $iscomplex = 0;
  }

  $dm = "dm($domainNumber)";
  if ($list[1] eq "s")
  {
    $nas[$domainNumber]++;
    $nn = $nas[$domainNumber];
    push @amat, mywrap("      $dm\%as($nn) = $string",$ncols);
    for($i=0;$i<$nloops;$i++) {push @amat, "      enddo\n";}
    push @imat,"      $dm\%asi(1,$nn) = $power\n";
    push @imat,"      $dm\%asi(2,$nn) = $der\n";
    push @imat,"      $dm\%asi(3,$nn) = $equation\n";
    push @imat,"      $dm\%asi(4,$nn) = $variable\n";
    push @imat,"      $dm\%asi(7,$nn) = $iscomplex\n";
    push @imat,"\n";
  }
  elsif ($list[1] eq "rt")
  {
    $nart[$domainNumber]++;
    $nn = $nart[$domainNumber];
    push @amat, mywrap("      $dm\%art($i_index,$j_index,$nn) = $string",$ncols);
    for($i=0;$i<$nloops;$i++) {push @amat, "      enddo\n";}
    push @imat,"      $dm\%arti(1,$nn) = $power\n";
    push @imat,"      $dm\%arti(2,$nn) = $der\n";
    push @imat,"      $dm\%arti(3,$nn) = $equation\n";
    push @imat,"      $dm\%arti(4,$nn) = $variable\n";
    push @imat,"      $dm\%arti(7,$nn) = $iscomplex\n";
    push @imat,"\n";
  }
  elsif ($list[1] eq "rtt")
  {
    $nartt[$domainNumber]++;
    $nn = $nartt[$domainNumber];
    push @amat, mywrap("      $dm\%artt($i_index,$j_index,$jj_index,$nn) = $string",$ncols);
    for($i=0;$i<$nloops;$i++) {push @amat, "      enddo\n";}
    push @imat,"      $dm\%artti(1,$nn) = $power\n";
    push @imat,"      $dm\%artti(2,$nn) = $der\n";
    push @imat,"      $dm\%artti(3,$nn) = $equation\n";
    push @imat,"      $dm\%artti(4,$nn) = $variable\n";
    push @imat,"      $dm\%artti(7,$nn) = $iscomplex\n";
    push @imat,"\n";
  }
  else {die "Error on line $src_nline[$nline]: unrecognised term type.\n";}
  $prev = $list[1];
  $dprev = $dm;
}
########################################################################
sub addtermbc{
  if (scalar @list < 6) {die "Error on line $src_nline[$nline]: missing terms.\n";}
  if (scalar @list > 6)
  {
    $list[4] = join(" ",@list[4..(scalar @list - 2)]);
    splice @list,5,-1;
  }

  $eqloc = $list[2];
  $eqloc =~ s/\$nr/grd($domainNumber)\%nr/g;

  $power = $list[3];
  $power =~ s/w(\d*)/$1/;
  if ($power eq "") {$power = 1;}
  if ($power > $power_max) {$power_max = $power;}

  $varloc = $list[5];
  $varloc =~ s/.*\((.*)\)/$1/;
  $list[5] =~ s/\(.*\)//;

  $der = $list[5];
  if ($der =~ /\^/) {
    $der =~ s/.*\^(.*)/$1/;
  }
  else {
    $der =~ s/[^']//g;
    $der = length($der);
  }

  $varname = $list[5];
  $varname =~ s/'//g;
  $varname =~ s/\^.*//;

  if (not exists $vardomain{$varname}) {
    die "Error on line $src_nline[$nline]: \"$varname\" unknown variable\n";
  }

  $varDomainNumber = $vardomain{$varname};
  $variable = $varindex{$varname};
  $varloc =~ s/\$nr/grd($varDomainNumber)\%nr/g;

  if (abs($varDomainNumber-$domainNumber) > 1) {
    die "Error on line $src_nline[$nline]: illegal domain coupling\n";
  }

  $string = $list[4];
  &treat_string;

  if ($list[0] eq 'termbci') {
    $iscomplex = 1;
  } else {
    $iscomplex = 0;
  }

  $idm = "idm($domainNumber,$varDomainNumber)";
  if ($list[1] eq "t")
  {
    $natbc[$domainNumber][$varDomainNumber]++;
    $nn = $natbc[$domainNumber][$varDomainNumber];
    push @amat, mywrap("      $idm\%atbc($j_index,$nn) = $string",$ncols);
    for($i=0;$i<$nloops;$i++) {push @amat, "      enddo\n";}
    push @imat,"      $idm\%atbci(1,$nn) = $power\n";
    push @imat,"      $idm\%atbci(2,$nn) = $der\n";
    push @imat,"      $idm\%atbci(3,$nn) = $equation\n";
    push @imat,"      $idm\%atbci(4,$nn) = $variable\n";
    push @imat,"      $idm\%atbci(5,$nn) = $eqloc\n";
    push @imat,"      $idm\%atbci(6,$nn) = $varloc\n";
    push @imat,"      $idm\%atbci(7,$nn) = $iscomplex\n";
    push @imat,"\n";
  }
  elsif ($list[1] eq "tt")
  {
    $nattbc[$domainNumber][$varDomainNumber]++;
    $nn = $nattbc[$domainNumber][$varDomainNumber];
    push @amat, mywrap("      $idm\%attbc($j_index,$jj_index,$nn) = $string",$ncols);
    for($i=0;$i<$nloops;$i++) {push @amat, "      enddo\n";}
    push @imat,"      $idm\%attbci(1,$nn) = $power\n";
    push @imat,"      $idm\%attbci(2,$nn) = $der\n";
    push @imat,"      $idm\%attbci(3,$nn) = $equation\n";
    push @imat,"      $idm\%attbci(4,$nn) = $variable\n";
    push @imat,"      $idm\%attbci(5,$nn) = $eqloc\n";
    push @imat,"      $idm\%attbci(6,$nn) = $varloc\n";
    push @imat,"      $idm\%attbci(7,$nn) = $iscomplex\n";
    push @imat,"\n";
  }
  else {die "Error on line $src_nline[$nline]: unrecognised term type.\n";}

  $prev = $list[1]."bc";
  $dprev = $idm;
}
########################################################################
sub callsub{
  if (scalar @list < 5) {die "Error on line $src_nline[$nline]: missing terms.\n";}
  if (scalar @list > 5)
  {
    $list[3] = join(" ",@list[3..(scalar @list - 2)]);
    splice @list,4,-1;
  }

  $power = $list[2];
  $power =~ s/w(\d*)/$1/;
  if ($power eq "") {$power = 1;}
  if ($power > $power_max) {$power_max = $power;}

  $der = $list[4];
  if ($der =~ /\^/) {
    $der =~ s/.*\^(.*)/$1/;
  }
  else {
    $der =~ s/[^']//g;
    $der = length($der);
  }

  $varname = $list[4];
  $varname =~ s/'//g;
  $varname =~ s/\^.*//;

  if (not exists $vardomain{$varname}) {
    die "Error on line $src_nline[$nline]: \"$varname\" unknown variable\n";
  }

  $varDomainNumber = $vardomain{$varname};
  $variable = $varindex{$varname};

  if ($varDomainNumber != $domainNumber) {
    die "Error on line $src_nline[$nline]: illegal domain coupling\n";
  }

  $string = $list[3];
  &treat_string;

  if ($list[0] eq 'subi') {
    $iscomplex = 1;
  } else {
    $iscomplex = 0;
  }

  $dm = "dm($domainNumber)";
  if ($list[1] eq "s")
  {
    $nas[$domainNumber]++;
    $nn = $nas[$domainNumber];
    $string =~ s/\$a/$dm\%as($nn)/g;
    push @amat, mywrap("      call $string",$ncols);
    for($i=0;$i<$nloops;$i++) {push @amat, "      enddo\n";}
    push @imat,"      $dm\%asi(1,$nn) = $power\n";
    push @imat,"      $dm\%asi(2,$nn) = $der\n";
    push @imat,"      $dm\%asi(3,$nn) = $equation\n";
    push @imat,"      $dm\%asi(4,$nn) = $variable\n";
    push @imat,"      $dm\%asi(7,$nn) = $iscomplex\n";
    push @imat,"\n";
  }
  elsif ($list[1] eq "rt")
  {
    $nart[$domainNumber]++;
    $nn = $nart[$domainNumber];
    $string =~ s/\$a/$dm\%art($i_index,$j_index,$nn)/g;
    push @amat, mywrap("      call $string",$ncols);
    for($i=0;$i<$nloops;$i++) {push @amat, "      enddo\n";}
    push @imat,"      $dm\%arti(1,$nn) = $power\n";
    push @imat,"      $dm\%arti(2,$nn) = $der\n";
    push @imat,"      $dm\%arti(3,$nn) = $equation\n";
    push @imat,"      $dm\%arti(4,$nn) = $variable\n";
    push @imat,"      $dm\%arti(7,$nn) = $iscomplex\n";
    push @imat,"\n";
  }
  elsif ($list[1] eq "rtt")
  {
    $nartt[$domainNumber]++;
    $nn = $nartt[$domainNumber];
    $string =~ s/\$a/$dm\%artt($i_index,$j_index,$jj_index,$nn)/g;
    push @amat, mywrap("      call $string",$ncols);
    for($i=0;$i<$nloops;$i++) {push @amat, "      enddo\n";}
    push @imat,"      $dm\%artti(1,$nn) = $power\n";
    push @imat,"      $dm\%artti(2,$nn) = $der\n";
    push @imat,"      $dm\%artti(3,$nn) = $equation\n";
    push @imat,"      $dm\%artti(4,$nn) = $variable\n";
    push @imat,"      $dm\%artti(7,$nn) = $iscomplex\n";
    push @imat,"\n";
  }
  else {die "Error on line $src_nline[$nline]: unrecognised term type.\n";}
  $prev = $list[1];
  $dprev = $dm;
}
########################################################################
sub callsubbc{
  if (scalar @list < 6) {die "Error on line $src_nline[$nline]: missing terms.\n";}
  if (scalar @list > 6)
  {
    $list[4] = join(" ",@list[4..(scalar @list - 2)]);
    splice @list,5,-1;
  }

  $eqloc = $list[2];
  $eqloc =~ s/\$nr/grd($domainNumber)\%nr/g;

  $power = $list[3];
  $power =~ s/w(\d*)/$1/;
  if ($power eq "") {$power = 1;}
  if ($power > $power_max) {$power_max = $power;}

  $varloc = $list[5];
  $varloc =~ s/.*\((.*)\).*/$1/;
  $list[5] =~ s/\(.*\)//;

  $der = $list[5];
  if ($der =~ /\^/) {
    $der =~ s/.*\^(.*)/$1/;
  }
  else {
    $der =~ s/[^']//g;
    $der = length($der);
  }

  $varname = $list[5];
  $varname =~ s/'//g;
  $varname =~ s/\^.*//;

  if (not exists $vardomain{$varname}) {
    die "Error on line $src_nline[$nline]: \"$varname\" unknown variable\n";
  }

  $varDomainNumber = $vardomain{$varname};
  $variable = $varindex{$varname};
  $varloc =~ s/\$nr/grd($varDomainNumber)\%nr/g;

  if (abs($varDomainNumber-$domainNumber) > 1) {
    die "Error on line $src_nline[$nline]: illegal domain coupling\n";
  }

  $string = $list[4];
  &treat_string;  

  if ($list[0] eq 'subbci') {
    $iscomplex = 1;
  } else {
    $iscomplex = 0;
  }

  $idm = "idm($domainNumber,$varDomainNumber)";
  if ($list[1] eq "t")
  {
    $natbc[$domainNumber][$varDomainNumber]++;
    $nn = $natbc[$domainNumber][$varDomainNumber];
    $string =~ s/\$a/$idm\%atbc($j_index,$nn)/;
    push @amat, mywrap("      call $string",$ncols);
    for($i=0;$i<$nloops;$i++) {push @amat, "      enddo\n";}
    push @imat,"      $idm\%atbci(1,$nn) = $power\n";
    push @imat,"      $idm\%atbci(2,$nn) = $der\n";
    push @imat,"      $idm\%atbci(3,$nn) = $equation\n";
    push @imat,"      $idm\%atbci(4,$nn) = $variable\n";
    push @imat,"      $idm\%atbci(5,$nn) = $eqloc\n";
    push @imat,"      $idm\%atbci(6,$nn) = $varloc\n";
    push @imat,"      $idm\%atbci(7,$nn) = $iscomplex\n";
    push @imat,"\n";
  }
  elsif ($list[1] eq "tt")
  {
    $nattbc[$domainNumber][$varDomainNumber]++;
    $nn = $nattbc[$domainNumber][$varDomainNumber];
    $string =~ s/\$a/$idm\%attbc($j_index,$jj_index,$nn)/;
    push @amat, mywrap("      call $string",$ncols);
    for($i=0;$i<$nloops;$i++) {push @amat, "      enddo\n";}
    push @imat,"      $idm\%attbci(1,$nn) = $power\n";
    push @imat,"      $idm\%attbci(2,$nn) = $der\n";
    push @imat,"      $idm\%attbci(3,$nn) = $equation\n";
    push @imat,"      $idm\%attbci(4,$nn) = $variable\n";
    push @imat,"      $idm\%attbci(5,$nn) = $eqloc\n";
    push @imat,"      $idm\%attbci(6,$nn) = $varloc\n";
    push @imat,"      $idm\%attbci(7,$nn) = $iscomplex\n";
    push @imat,"\n";
  }
  else {die "Error on line $src_nline[$nline]: unrecognised term type.\n";}
  $prev = $list[1]."bc";
  $dprev = $idm;
}
########################################################################
sub addinput{
  if (scalar @list < 3) {die "Error on line $src_nline[$nline]: missing terms.\n";}
  if (scalar @list > 3) {die "Error on line $src_nline[$nline]: too many terms.\n";}

  push @inputs, $list[1];
  push @inputs_format, $list[2];

  $datatype = "notype";
  if ($list[2] =~ m/.*[iI].*/)   {$datatype="integer";$value="0";}
  if ($list[2] =~ m/.*[fF].*/)   {$datatype="double precision";$value="0d0"}
  if ($list[2] =~ m/.*[eEdD].*/) {$datatype="double precision";$value="0d0"}
  if ($list[2] =~ m/.*[aA].*/)
  {
    $numchar = $list[2];
    $numchar =~ s/.*[aA](.*)/$1/;
    $datatype = "character*($numchar)";
    $value = '" "';
  }

  if ($datatype eq "notype")
    {die "Unrecognised format specifier on line $src_nline[$nline].\n";}
  push @inputs_datatype, $datatype;
  push @inputs_value, $value;
}
########################################################################
sub writegrid{
  $grid_file = "mod_grid.F90";
  open(GRID, "> $grid_file") or die "File $grid_file cannot be created.\n";
  print GRID 
"       module mod_grid

       type GRID
         character*(4) :: mattype
         character*(4) :: dertype
         integer :: order
         integer :: nr
         double precision, pointer :: r(:)
       end type GRID

       integer, parameter :: ndomains = $ndomains
       integer, save      :: nt
       type(GRID), save   :: grd(ndomains)

       end module";
  close GRID;
}
########################################################################
sub writeinputs{
  $input_file  = "inputs.F90";
  open(INPUTS, "> $input_file") or die "File $input_file cannot be created.\n";
  print INPUTS "      module inputs\n\n";
  print INPUTS "      use iso_c_binding\n";
  print INPUTS "      use string\n";
  print INPUTS "      use mod_grid\n";
  for ($i=0; $i < scalar @inputs; $i++)
    {print INPUTS "      $inputs_datatype[$i], save :: $inputs[$i]\n";}
  for($i=0; $i < scalar @defs; $i++) 
    {print INPUTS "      $defs_type[$i], save :: $defs[$i]\n";}

  if (length($stamp) > 0)
  {
    print INPUTS "      character*(".length($stamp)."), parameter :: stamp = & \n";
    print INPUTS "       \"$stamp\"\n";
  }

  print INPUTS "\ncontains\n";
  print INPUTS "!".("-"x60)."\n";
  print INPUTS "      subroutine read_inputs(dati, n) bind(c)\n\n";
  print INPUTS "      use mgetpar\n";
  print INPUTS "      implicit none\n\n";
  print INPUTS "      integer(kind=c_int), intent(in) :: n\n";
  print INPUTS "      character(kind=c_char), intent(in) :: dati(n)\n";
  print INPUTS "      call init_grid($ndomains)\n";
  print INPUTS "      call read_file(trim(cpy_str(dati)))\n";
  for ($i=1;$i <= $ndomains;$i++) {
    $grd = "grd($i)";
    print INPUTS "      $grd\%nr = fetch('nr($i)',0)\n";
    print INPUTS "      $grd\%order = fetch('order($i)',2)\n";
    print INPUTS "      $grd\%dertype = fetch('dertype($i)','CHEB')\n";
    print INPUTS "      $grd\%mattype = fetch('mattype($i)','FULL')\n";
  }
  print INPUTS "      nt = fetch('nt',0)\n";
  for ($i=0; $i < scalar @inputs; $i++)
    {print INPUTS "      $inputs[$i] = fetch('$inputs[$i]',$inputs_value[$i])\n";}
  print INPUTS "\n      end subroutine\n";
  print INPUTS "!".("-"x60)."\n";
  print INPUTS "      subroutine write_inputs(iu)\n\n";
  print INPUTS "      implicit none\n\n";
  print INPUTS "      integer iu\n\n";
  print INPUTS "      write(iu,101) &\n";  
  for ($i=1;$i <= $ndomains;$i++) {
    $grd = "grd($i)";
    print INPUTS "          $grd\%nr, & ! this corresponds to nr+1 when using postvecp \n"; 
    print INPUTS "          $grd\%order, &\n";
    print INPUTS "          trim($grd\%dertype), &\n";
    print INPUTS "          trim($grd\%mattype), &\n";
  }
  print INPUTS "          nt, &\n";
  for ($i=0; $i < scalar @inputs-1; $i++) {
    if ($inputs_format[$i] =~ m/.*[aA].*/) {
      print INPUTS "          trim($inputs[$i]), &\n";
    } else {
      print INPUTS "          $inputs[$i], &\n";
    }
  }
  $i = scalar @inputs - 1;
  if ($inputs_format[$i] =~ m/.*[aA].*/) {
    print INPUTS "          trim($inputs[$i])\n";
  } else {
    print INPUTS "          $inputs[$i]\n";
  }
  print INPUTS "101   format( &\n";
  for ($i=1;$i <= $ndomains;$i++) {
    $grd = "grd($ndomains)";
    print INPUTS "          '  nr($i)=',I4, &\n";
    print INPUTS "          '  order($i)=',I2, &\n";
    print INPUTS "          '  dertype($i)=',A, &\n";
    print INPUTS "          '  mattype($i)=',A, &\n";
  }
  print INPUTS "          '  nt=',I3, &\n";
  for ($i=0; $i < scalar @inputs-1; $i++) {
    if ($inputs_format[$i] =~ m/.*[aA].*/) {
      print INPUTS "          '  $inputs[$i]=',A, &\n";
    } else {
      print INPUTS "          '  $inputs[$i]=',$inputs_format[$i], &\n";
    }
  }
  $i = scalar @inputs - 1;
  if ($inputs_format[$i] =~ m/.*[aA].*/) {
    print INPUTS "          '  $inputs[$i]=',A)\n";
  } else {
    print INPUTS "          '  $inputs[$i]=',$inputs_format[$i])\n";
  }
  print INPUTS "      end subroutine\n";
  print INPUTS "!".("-"x60)."\n";
  print INPUTS "      subroutine write_stamp(iu)\n\n";
  print INPUTS "      implicit none\n\n";
  print INPUTS "      integer iu\n\n";
  print INPUTS "      write(iu,'(\"stamp = \",a".length($stamp).")') stamp\n";  
  print INPUTS "      end subroutine\n";
  print INPUTS "!".("-"x60)."\n";
  print INPUTS "      end module\n";
  close INPUTS ;
}
########################################################################
# Function copied and adapted from LSB, written by L. Valdetarro
# This wraps a text ($_[0]) to $_[1] columns
sub mywrap{
   my $str   = $_[0];
   my $ncols = $_[1];
   my $str1  = "";
   @strsplit=split(/\n/,$str);

   foreach $str (@strsplit){
      $str =~ s/\s+$//; # remove trailing blanks (just in case)
      while(length($str) > $ncols) {
        $str1.=substr($str,0,$ncols)."&\n&";
        $str2=substr($str,$ncols);
        $str=$str2;
      }
      $str1.=$str."\n";
   }
   return $str1;
}
########################################################################
sub treat_string{
  $nloops = 0;
  $i_index = "1:grd($varDomainNumber)\%nr";
  $j_index = "1:nt";
  $jj_index = "1:nt";

  while ($string =~ m/\$lvar\(.*\)/) {$string =~ s/\$lvar\(([^)]*)\)/dm($varDomainNumber)\%lvar($1,$variable)/;}
  $string =~ s/\$lvar/dm($varDomainNumber)\%lvar(1:nt,$variable)/g;
  while ($string =~ m/\$leq\(.*\)/) {$string =~ s/\$leq\(([^)]*)\)/dm($domainNumber)\%leq($1,$equation)/g;}
  $string =~ s/\$leq/dm($domainNumber)\%leq(1:nt,$equation)/g;
  $string =~ s/\$var/$variable/g;
  $string =~ s/\$eq/$equation/g; 
  $string =~ s/\$nr/grd($varDomainNumber)\%nr/g;

  if ($string =~ m/\$i/)
  {
    push @amat, "      do i=1,grd($varDomainNumber)\%nr\n";
    $nloops++;
    $i_index = "i";
  }

  if ($string =~ m/\$j1/)
  {
    push @amat, "      do j=1,nt\n";
    $nloops++;
    $j_index = "j";
  }

  if ($string =~ m/\$j2/)
  {
    push @amat, "      do jj=1,nt\n";
    $nloops++;
    $jj_index = "jj";
  }

  $string =~ s/\$i/i/g;
  $string =~ s/\$j1/j/g;
  $string =~ s/\$j2/jj/g;

  if ($string =~ m/\$prev/)
  {
       if ($prev eq "s")     {$string =~ s/\$prev/$dm\%as($nn)/g;}
    elsif ($prev eq "rt")    {$string =~ s/\$prev/$dm\%art($i_index,$j_index,$nn)/g;}
    elsif ($prev eq "rtt")   {$string =~ s/\$prev/$dm\%artt($i_index,$j_index,$jj_index,$nn)/g;}
    elsif ($prev eq "tbc")   {$string =~ s/\$prev/$idm\%atbc($j_index,$nn)/g;}
    elsif ($prev eq "ttbc")  {$string =~ s/\$prev/$idm\%attbc($j_index,$jj_index,$nn)/g;}
    elsif ($prev eq "empty") {die "Error on line $src_nline[$nline]: instruction on non-existant term\n";}
    else {die "Error on line $src_nline[$nline]: Programming error in readeq\n";}
  }
}
########################################################################
